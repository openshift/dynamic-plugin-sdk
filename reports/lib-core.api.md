## API Report File for "@openshift/dynamic-plugin-sdk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as React_2 from 'react';

// @public
export type AnyObject = Record<string, unknown>;

// @public
export const applyCodeRefSymbol: <T extends CodeRef<unknown>>(codeRef: T) => T;

// @public
export const applyDefaults: <TObject>(obj: TObject, defaults: unknown) => TObject;

// @public
export const applyOverrides: <TObject>(obj: TObject, overrides: unknown) => TObject;

// @public
export type CodeRef<TValue = unknown> = () => Promise<TValue>;

// @public (undocumented)
export type CodeRefsToEncodedCodeRefs<T> = T extends CodeRef ? EncodedCodeRef : T extends (infer U)[] ? CodeRefsToEncodedCodeRefs<U>[] : T extends object ? MapCodeRefsToEncodedCodeRefs<T> : T;

// @public (undocumented)
export type CodeRefsToValues<T> = T extends CodeRef<infer TValue> ? TValue : T extends (infer U)[] ? CodeRefsToValues<U>[] : T extends object ? MapCodeRefsToValues<T> : T;

// @public
export const consoleLogger: Logger;

// @public
export class CustomError extends Error {
    constructor(message?: string);
}

// @public
export type EitherNotBoth<TypeA, TypeB> = (TypeA & Never<TypeB>) | (TypeB & Never<TypeA>);

// @public
export type EitherOrNone<TypeA, TypeB> = EitherNotBoth<TypeA, TypeB> | (Never<TypeA> & Never<TypeB>);

// @public
export type EncodedCodeRef = {
    $codeRef: string;
};

// @public
export type EncodedExtension<TExtension extends Extension = Extension> = ReplaceProperties<TExtension, {
    properties: ReplaceProperties<ExtractExtensionProperties<TExtension>, MapCodeRefsToEncodedCodeRefs<ExtractExtensionProperties<TExtension>>>;
}>;

// @public
export type Extension<TType extends string = string, TProperties extends AnyObject = AnyObject> = {
    type: TType;
    properties: TProperties;
    flags?: ExtensionFlags;
    [customProperty: string]: unknown;
};

// @public
export type ExtensionFlags = Partial<{
    required: string[];
    disallowed: string[];
}>;

// @public
export type ExtensionPredicate<TExtension extends Extension> = (e: Extension) => e is TExtension;

// @public
export type ExtractExtensionProperties<T> = T extends Extension<any, infer TProperties> ? TProperties : never;

// @public
export type FailedPlugin = {
    manifest: Readonly<PluginManifest>;
    errorMessage: string;
    errorCause?: unknown;
};

// @public
export type FailedPluginInfoEntry = {
    status: 'failed';
} & Pick<FailedPlugin, 'manifest' | 'errorMessage' | 'errorCause'>;

// @public
export type FeatureFlags = {
    [flagName: string]: boolean;
};

// @public
export type LoadedExtension<TExtension extends Extension = Extension> = TExtension & {
    pluginName: string;
    uid: string;
};

// @public
export type LoadedPlugin = {
    manifest: Readonly<PluginManifest>;
    loadedExtensions: Readonly<LoadedExtension[]>;
    entryModule?: PluginEntryModule;
    enabled: boolean;
    disableReason?: string;
};

// @public
export type LoadedPluginInfoEntry = {
    status: 'loaded';
} & Pick<LoadedPlugin, 'manifest' | 'enabled' | 'disableReason'>;

// @public
export type LocalPluginManifest = PluginRuntimeMetadata & {
    extensions: Extension[];
    registrationMethod: 'local';
};

// @public (undocumented)
export type LogFunction = (message?: any, ...optionalParams: any[]) => void;

// @public
export type Logger = Record<'info' | 'warn' | 'error', LogFunction>;

// @public (undocumented)
export type MapCodeRefsToEncodedCodeRefs<T extends object> = {
    [K in keyof T]: CodeRefsToEncodedCodeRefs<T[K]>;
};

// @public (undocumented)
export type MapCodeRefsToValues<T extends object> = {
    [K in keyof T]: CodeRefsToValues<T[K]>;
};

// @public
export type Never<T> = {
    [K in keyof T]?: never;
};

// @public
export type PendingPlugin = {
    manifest: Readonly<PluginManifest>;
};

// @public
export type PendingPluginInfoEntry = {
    status: 'pending';
} & Pick<PendingPlugin, 'manifest'>;

// @public
export type PluginEntryModule = {
    init: (sharedScope: AnyObject) => void | Promise<void>;
    get: <TModule extends AnyObject>(moduleRequest: string) => Promise<() => TModule>;
};

// @public (undocumented)
export enum PluginEventType {
    ExtensionsChanged = "ExtensionsChanged",
    FeatureFlagsChanged = "FeatureFlagsChanged",
    PluginInfoChanged = "PluginInfoChanged"
}

// @public (undocumented)
export type PluginInfoEntry = PendingPluginInfoEntry | LoadedPluginInfoEntry | FailedPluginInfoEntry;

// @public
export class PluginLoader implements PluginLoaderInterface {
    constructor(options?: PluginLoaderOptions);
    // (undocumented)
    loadPlugin(manifest: PluginManifest): Promise<PluginLoadResult>;
    // (undocumented)
    loadPluginManifest(manifestURL: string): Promise<RemotePluginManifest>;
    registerPluginEntryCallback(): void;
    // (undocumented)
    transformPluginManifest<T extends PluginManifest>(manifest: T): T;
}

// @public
export type PluginLoaderInterface = {
    loadPluginManifest: (manifestURL: string) => Promise<RemotePluginManifest>;
    transformPluginManifest: <T extends PluginManifest>(manifest: T) => T;
    loadPlugin: (manifest: PluginManifest) => Promise<PluginLoadResult>;
};

// @public (undocumented)
export type PluginLoaderOptions = Partial<{
    canLoadPlugin: (manifest: PluginManifest, reload: boolean) => boolean;
    canReloadScript: (manifest: RemotePluginManifest, scriptName: string) => boolean;
    entryCallbackSettings: Partial<{
        registerCallback: boolean;
        name: string;
    }>;
    fetchImpl: ResourceFetch;
    fixedPluginDependencyResolutions: Record<string, string>;
    sharedScope: AnyObject;
    transformPluginManifest: <T extends PluginManifest>(manifest: T) => T;
    getPluginEntryModule: (manifest: RemotePluginManifest) => PluginEntryModule | void;
}>;

// @public (undocumented)
export type PluginLoadResult = {
    success: true;
    loadedExtensions: LoadedExtension[];
    entryModule?: PluginEntryModule;
} | {
    success: false;
    errorMessage: string;
    errorCause?: unknown;
};

// @public (undocumented)
export type PluginManifest = RemotePluginManifest | LocalPluginManifest;

// @public
export type PluginRuntimeMetadata = {
    name: string;
    version: string;
    dependencies?: Record<string, string>;
    optionalDependencies?: Record<string, string>;
    customProperties?: AnyObject;
};

// @public
export class PluginStore implements PluginStoreInterface {
    constructor(options?: PluginStoreOptions & PluginStoreLoaderSettings);
    // (undocumented)
    protected addFailedPlugin(manifest: PluginManifest, errorMessage: string, errorCause?: unknown): void;
    // (undocumented)
    protected addLoadedPlugin(manifest: PluginManifest, loadedExtensions: LoadedExtension[], entryModule?: PluginEntryModule): void;
    // (undocumented)
    protected addPendingPlugin(manifest: PluginManifest): void;
    // (undocumented)
    disablePlugins(pluginNames: string[], disableReason?: string): void;
    // (undocumented)
    enablePlugins(pluginNames: string[]): void;
    // (undocumented)
    getExposedModule<TModule extends AnyObject>(pluginName: string, moduleName: string): Promise<TModule>;
    // (undocumented)
    getExtensions(): LoadedExtension<Extension<string, AnyObject>>[];
    // (undocumented)
    getFeatureFlags(): {
        [x: string]: boolean;
    };
    // (undocumented)
    getPluginInfo(): PluginInfoEntry[];
    // (undocumented)
    loadPlugin(manifest: PluginManifest | string, forceReload?: boolean): Promise<void>;
    // (undocumented)
    readonly sdkVersion: string;
    // (undocumented)
    setFeatureFlags(newFlags: FeatureFlags): void;
    // (undocumented)
    subscribe(eventTypes: PluginEventType[], listener: VoidFunction): VoidFunction;
}

// @public
export type PluginStoreInterface = {
    readonly sdkVersion: string;
    subscribe: (eventTypes: PluginEventType[], listener: VoidFunction) => VoidFunction;
    getExtensions: () => LoadedExtension[];
    getPluginInfo: () => PluginInfoEntry[];
    getFeatureFlags: () => FeatureFlags;
    setFeatureFlags: (newFlags: FeatureFlags) => void;
    loadPlugin: (manifest: PluginManifest | string, forceReload?: boolean) => Promise<void>;
    enablePlugins: (pluginNames: string[]) => void;
    disablePlugins: (pluginNames: string[], disableReason?: string) => void;
    getExposedModule: <TModule extends AnyObject>(pluginName: string, moduleName: string) => Promise<TModule>;
};

// @public (undocumented)
export type PluginStoreLoaderSettings = EitherNotBoth<{
    loaderOptions?: PluginLoaderOptions;
}, {
    loader: PluginLoaderInterface;
}>;

// @public (undocumented)
export type PluginStoreOptions = Partial<{
    autoEnableLoadedPlugins: boolean;
}>;

// @public
export const PluginStoreProvider: React_2.FC<PluginStoreProviderProps>;

// @public (undocumented)
export type PluginStoreProviderProps = React_2.PropsWithChildren<{
    store: PluginStoreInterface;
}>;

// @public
export type RemotePluginManifest = PluginRuntimeMetadata & {
    baseURL: string;
    extensions: Extension[];
    loadScripts: string[];
    registrationMethod: 'callback' | 'custom';
    buildHash?: string;
};

// @public
export type ReplaceProperties<T, R> = {
    [K in keyof T]: K extends keyof R ? R[K] : T[K];
};

// @public
export type ResolvedExtension<TExtension extends Extension = Extension> = ReplaceProperties<TExtension, {
    properties: ReplaceProperties<ExtractExtensionProperties<TExtension>, MapCodeRefsToValues<ExtractExtensionProperties<TExtension>>>;
}>;

// @public
export type ResourceFetch = (url: string, requestInit?: RequestInit, isK8sAPIRequest?: boolean) => Promise<Response>;

// @public
export class TestPluginStore extends PluginStore {
    // (undocumented)
    addFailedPlugin(...args: Parameters<PluginStore['addFailedPlugin']>): void;
    // (undocumented)
    addLoadedPlugin(...args: Parameters<PluginStore['addLoadedPlugin']>): void;
    // (undocumented)
    addPendingPlugin(...args: Parameters<PluginStore['addPendingPlugin']>): void;
}

// @public
export const useExtensions: <TExtension extends Extension<string, AnyObject>>(predicate?: ExtensionPredicate<TExtension> | undefined) => LoadedExtension<TExtension>[];

// @public
export const useFeatureFlag: (name: string) => UseFeatureFlagResult;

// @public (undocumented)
export type UseFeatureFlagResult = [currentValue: boolean, setValue: (newValue: boolean) => void];

// @public
export const usePluginInfo: () => PluginInfoEntry[];

// @public
export const usePluginStore: () => PluginStoreInterface;

// @public
export const useResolvedExtensions: <TExtension extends Extension<string, AnyObject>>(predicate?: ExtensionPredicate<TExtension> | undefined, options?: UseResolvedExtensionsOptions) => UseResolvedExtensionsResult<TExtension>;

// @public (undocumented)
export type UseResolvedExtensionsOptions = Partial<{
    includeExtensionsWithResolutionErrors: boolean;
}>;

// @public (undocumented)
export type UseResolvedExtensionsResult<TExtension extends Extension> = [
resolvedExtensions: LoadedExtension<ResolvedExtension<TExtension>>[],
resolved: boolean,
errors: unknown[]
];

```
